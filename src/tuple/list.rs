use std::fmt::Debug;

use crate::result::{ErrorKind, IResult};

pub trait TupleList<I, O> {
    fn parse(&self, input: I) -> IResult<I, O>;
}

// these code are generated by script
// Do not try to read!
// todo: replace with macro
impl<I: Copy + Debug, F0, O0, F1, O1> TupleList<I, (O0, O1)> for (F0, F1)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1)> {
        let (f0, f1) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        Ok((current, (result0, result1)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2> TupleList<I, (O0, O1, O2)> for (F0, F1, F2)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2)> {
        let (f0, f1, f2) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        Ok((current, (result0, result1, result2)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3> TupleList<I, (O0, O1, O2, O3)> for (F0, F1, F2, F3)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3)> {
        let (f0, f1, f2, f3) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        Ok((current, (result0, result1, result2, result3)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4> TupleList<I, (O0, O1, O2, O3, O4)> for (F0, F1, F2, F3, F4)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4)> {
        let (f0, f1, f2, f3, f4) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5> TupleList<I, (O0, O1, O2, O3, O4, O5)> for (F0, F1, F2, F3, F4, F5)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5)> {
        let (f0, f1, f2, f3, f4, f5) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6> TupleList<I, (O0, O1, O2, O3, O4, O5, O6)> for (F0, F1, F2, F3, F4, F5, F6)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6)> {
        let (f0, f1, f2, f3, f4, f5, f6) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7)> for (F0, F1, F2, F3, F4, F5, F6, F7)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13, F14, O14> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13>, F14: Fn(I) -> IResult<I, O14> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        let part_14_result = f14(current);
        if part_14_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result14) = part_14_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13, F14, O14, F15, O15> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13>, F14: Fn(I) -> IResult<I, O14>, F15: Fn(I) -> IResult<I, O15> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        let part_14_result = f14(current);
        if part_14_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result14) = part_14_result.unwrap();
        let part_15_result = f15(current);
        if part_15_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result15) = part_15_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13, F14, O14, F15, O15, F16, O16> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13>, F14: Fn(I) -> IResult<I, O14>, F15: Fn(I) -> IResult<I, O15>, F16: Fn(I) -> IResult<I, O16> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        let part_14_result = f14(current);
        if part_14_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result14) = part_14_result.unwrap();
        let part_15_result = f15(current);
        if part_15_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result15) = part_15_result.unwrap();
        let part_16_result = f16(current);
        if part_16_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result16) = part_16_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15, result16)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13, F14, O14, F15, O15, F16, O16, F17, O17> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13>, F14: Fn(I) -> IResult<I, O14>, F15: Fn(I) -> IResult<I, O15>, F16: Fn(I) -> IResult<I, O16>, F17: Fn(I) -> IResult<I, O17> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        let part_14_result = f14(current);
        if part_14_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result14) = part_14_result.unwrap();
        let part_15_result = f15(current);
        if part_15_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result15) = part_15_result.unwrap();
        let part_16_result = f16(current);
        if part_16_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result16) = part_16_result.unwrap();
        let part_17_result = f17(current);
        if part_17_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result17) = part_17_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15, result16, result17)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13, F14, O14, F15, O15, F16, O16, F17, O17, F18, O18> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13>, F14: Fn(I) -> IResult<I, O14>, F15: Fn(I) -> IResult<I, O15>, F16: Fn(I) -> IResult<I, O16>, F17: Fn(I) -> IResult<I, O17>, F18: Fn(I) -> IResult<I, O18> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        let part_14_result = f14(current);
        if part_14_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result14) = part_14_result.unwrap();
        let part_15_result = f15(current);
        if part_15_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result15) = part_15_result.unwrap();
        let part_16_result = f16(current);
        if part_16_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result16) = part_16_result.unwrap();
        let part_17_result = f17(current);
        if part_17_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result17) = part_17_result.unwrap();
        let part_18_result = f18(current);
        if part_18_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result18) = part_18_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15, result16, result17, result18)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13, F14, O14, F15, O15, F16, O16, F17, O17, F18, O18, F19, O19> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13>, F14: Fn(I) -> IResult<I, O14>, F15: Fn(I) -> IResult<I, O15>, F16: Fn(I) -> IResult<I, O16>, F17: Fn(I) -> IResult<I, O17>, F18: Fn(I) -> IResult<I, O18>, F19: Fn(I) -> IResult<I, O19> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        let part_14_result = f14(current);
        if part_14_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result14) = part_14_result.unwrap();
        let part_15_result = f15(current);
        if part_15_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result15) = part_15_result.unwrap();
        let part_16_result = f16(current);
        if part_16_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result16) = part_16_result.unwrap();
        let part_17_result = f17(current);
        if part_17_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result17) = part_17_result.unwrap();
        let part_18_result = f18(current);
        if part_18_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result18) = part_18_result.unwrap();
        let part_19_result = f19(current);
        if part_19_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result19) = part_19_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15, result16, result17, result18, result19)))
    }
}

impl<I: Copy + Debug, F0, O0, F1, O1, F2, O2, F3, O3, F4, O4, F5, O5, F6, O6, F7, O7, F8, O8, F9, O9, F10, O10, F11, O11, F12, O12, F13, O13, F14, O14, F15, O15, F16, O16, F17, O17, F18, O18, F19, O19, F20, O20> TupleList<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20)> for (F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20)
    where F0: Fn(I) -> IResult<I, O0>, F1: Fn(I) -> IResult<I, O1>, F2: Fn(I) -> IResult<I, O2>, F3: Fn(I) -> IResult<I, O3>, F4: Fn(I) -> IResult<I, O4>, F5: Fn(I) -> IResult<I, O5>, F6: Fn(I) -> IResult<I, O6>, F7: Fn(I) -> IResult<I, O7>, F8: Fn(I) -> IResult<I, O8>, F9: Fn(I) -> IResult<I, O9>, F10: Fn(I) -> IResult<I, O10>, F11: Fn(I) -> IResult<I, O11>, F12: Fn(I) -> IResult<I, O12>, F13: Fn(I) -> IResult<I, O13>, F14: Fn(I) -> IResult<I, O14>, F15: Fn(I) -> IResult<I, O15>, F16: Fn(I) -> IResult<I, O16>, F17: Fn(I) -> IResult<I, O17>, F18: Fn(I) -> IResult<I, O18>, F19: Fn(I) -> IResult<I, O19>, F20: Fn(I) -> IResult<I, O20> {
    fn parse(&self, input: I) -> IResult<I, (O0, O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11, O12, O13, O14, O15, O16, O17, O18, O19, O20)> {
        let (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20) = self;
        let current = input;
        let part_0_result = f0(current);
        if part_0_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result0) = part_0_result.unwrap();
        let part_1_result = f1(current);
        if part_1_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result1) = part_1_result.unwrap();
        let part_2_result = f2(current);
        if part_2_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result2) = part_2_result.unwrap();
        let part_3_result = f3(current);
        if part_3_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result3) = part_3_result.unwrap();
        let part_4_result = f4(current);
        if part_4_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result4) = part_4_result.unwrap();
        let part_5_result = f5(current);
        if part_5_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result5) = part_5_result.unwrap();
        let part_6_result = f6(current);
        if part_6_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result6) = part_6_result.unwrap();
        let part_7_result = f7(current);
        if part_7_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result7) = part_7_result.unwrap();
        let part_8_result = f8(current);
        if part_8_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result8) = part_8_result.unwrap();
        let part_9_result = f9(current);
        if part_9_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result9) = part_9_result.unwrap();
        let part_10_result = f10(current);
        if part_10_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result10) = part_10_result.unwrap();
        let part_11_result = f11(current);
        if part_11_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result11) = part_11_result.unwrap();
        let part_12_result = f12(current);
        if part_12_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result12) = part_12_result.unwrap();
        let part_13_result = f13(current);
        if part_13_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result13) = part_13_result.unwrap();
        let part_14_result = f14(current);
        if part_14_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result14) = part_14_result.unwrap();
        let part_15_result = f15(current);
        if part_15_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result15) = part_15_result.unwrap();
        let part_16_result = f16(current);
        if part_16_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result16) = part_16_result.unwrap();
        let part_17_result = f17(current);
        if part_17_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result17) = part_17_result.unwrap();
        let part_18_result = f18(current);
        if part_18_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result18) = part_18_result.unwrap();
        let part_19_result = f19(current);
        if part_19_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result19) = part_19_result.unwrap();
        let part_20_result = f20(current);
        if part_20_result.is_err() {
            return Err((current, ErrorKind::Tuple));
        }
        let (current, result20) = part_20_result.unwrap();
        Ok((current, (result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15, result16, result17, result18, result19, result20)))
    }
}

